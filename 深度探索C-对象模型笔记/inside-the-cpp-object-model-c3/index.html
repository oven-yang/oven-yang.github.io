<!doctype html>
<html>
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable"  content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no">
    <meta name="google-site-verification" content="MRzl-5EI6CWkMCxLu0gLw3OkM2AMKtugzBFbtcASBL4" />
    <meta name="baidu-site-verification" content="axvUetvw04" />
    
    
    <!--Simple SEO-->

<meta name="description" content=一蓑烟雨任平生/>


<meta name="robots" content=all />
<meta name="google" content=all />
<meta name="googlebot" content=all />
<meta name="verify" content=all />
    <!--Title-->

<title>第3章 Data语意学 | 杨文的博客</title>


<link rel="icon" href="/archlinux.ico">

    
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/pages/post.css">
<link rel="stylesheet" href="/css/thirdParty/font-awesome.min.css">
<link rel="stylesheet" href="/css/thirdParty/highlight/github.css">
<link rel="stylesheet" href="/.css">

    <!--script-->



<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>-->


    
    
</head>

<body id="normal">
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<style>
    header{ top: 71px; position: absolute!important;}
    #container{padding-top: 151px!important;}
</style>
<div style="position:fixed;z-index:9999;left:0;top:0;width:100%;height:70px;background-color:#e0e0e0;color:#396CA5;border-bottom:1px solid #cecece;text-align:center;line-height:70px;white-space: nowrap;overflow: hidden;text-overflow: ellipsis">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<div id="wrap">
    <header  style="position: absolute;" >
    <div id="site-meta">
        <a href="/" id="logo">
            <h1 class="title">杨文的博客</h1>
        </a>
        
    </div>
    <ul id="nav">
        
            <li><a href="/"><i class="fa fa-home"></i>Home</a></li>
        
            <li><a href="https://www.github.com/oven-yang"><i class="fa fa-github"></i>github</a></li>
        
        <li id="search"><a href="javascript:void(0)"><i class="fa fa-search"></i>Search</a></li>
    </ul>
</header>

    <div id="container">
        
<ul id="sidebar">
    
    
<li class="widget notification">
    <i class="fa fa-bell-o"></i>
    <div>
        
<p>你好, 欢迎来信交流.</p>
<p>你可通过<a href="mailto:mg6150@outlook.com">我的邮箱</a>联系我</p>
    </div>
</li>

    
    
<li class="widget widget-normal category">
    <h3 class="fa fa-th widget-title">Categories</h3>
    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/"><i class="fa" aria-hidden="true">C++</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度探索C-对象模型笔记/"><i class="fa" aria-hidden="true">深度探索C++对象模型笔记</i></a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文研读/"><i class="fa" aria-hidden="true">论文研读</i></a><span class="category-list-count">6</span></li></ul>
</li>


    
    
<li class="widget widget-normal archive">
  <h3 class="fa fa-archive widget-title">Archives</h3>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/"><i class="fa" aria-hidden="true">May 2019</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/"><i class="fa" aria-hidden="true">October 2018</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/"><i class="fa" aria-hidden="true">September 2018</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/"><i class="fa" aria-hidden="true">August 2018</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/"><i class="fa" aria-hidden="true">November 2017</i></a><span class="archive-list-count">1</span></li></ul>
</li>


    
    
<li class="widget widget-normal popular-posts" id="popular-posts" hidden>
    <h3 class="fa fa-thermometer-3 widget-title">Popular Posts</h3>
    <ul id="popular-content">
        <li class="load-first"><i class="fa fa-spinner fa-pulse"></i></li>
    </ul>
</li>


    
    
<li class="widget widget-normal tags">
  <h3 class="fa fa-tags widget-title">Tag Cloud</h3>
  <div class="tagcloud-content">
    
      <a href="/tags/C/" style="font-size: 0.5rem; color: #0a407c">C++</a> <a href="/tags/分布式/" style="font-size: 0.5rem; color: #0a407c">分布式</a> <a href="/tags/consensus/" style="font-size: 0.14rem; color: #69c">consensus</a>
  </div>
</li>


    
    
<li class="widget widget-normal friends-link" hidden>
    <h3 class="fa fa-globe widget-title">Friends</h3><br/>

    
        <a href="http://geekaholiclin.github.io" class="fa" target="_blank">主题作者</a>

    

</li>


    
</ul>


        <div id="main">
    <article id="post">
        <div id="post-header">

            <h1 id="第3章 Data语意学">
                
                第3章 Data语意学
                
            </h1>
            <div class="article-meta">
    
    
    <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
        <span>深度探索C++对象模型笔记</span>
    </span>
    
    
    <span class="fa-wrap">
         <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            C++
            
        </span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta ">2018/10/19</span>
    </span>
    
    
    <span class="fa-wrap" hidden>
            <i class="fa fa-thermometer-three-quarters"></i>
        <span class="hits hits-meta " data-leadcloud-title="第3章 Data语意学"
              data-leadcloud-url="/深度探索C-对象模型笔记/inside-the-cpp-object-model-c3/"><i class="fa fa-spinner fa-spin"></i></span>
    </span>
    
    
</div>

            
            
        </div>
        
        <div id="post-body">
            <p>这一章主要进一步讨论C++对象的内存布局, 特别是在引入继承, 虚函数, 多继承, 虚继承后对内存布局的影响,
还包含编译器对相关特性的实现方式和优化.</p>
<p>注意, 下面的代码运行于Archlinux 4.18 x86_64, 编译器是gcc 8, 使用gdb 8调试.</p>
<h2 id="不含数据成员的类对象"><a href="#不含数据成员的类对象" class="headerlink" title="不含数据成员的类对象"></a>不含数据成员的类对象</h2><p>对于不存在继承和虚函数的类, 没有数据成员时, 其大小至少是1 byte, 以保证变量有唯一的地址.
当加上虚函数后, 由于有虚函数指针, 对象大小等于一个指针的大小, 32位系统中是4 bytes, 64位系统中是8 bytes.
看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Empty</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VirtualEmpty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Empty a;</span><br><span class="line">Empty b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Empty)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(VirtualEmpty)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">' '</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 在输出中可以看到b的地址比a的地址大一.</span></span><br></pre></td></tr></table></figure>
<p>但是, 当其作为基类时, 在某些情况下则不必遵循上面的要求, 可以在子类中将其优化掉, 节省所占空间.
例如下面的情况:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Base)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Derived)&lt;&lt;<span class="built_in">endl</span> <span class="comment">// 输出为8</span></span><br></pre></td></tr></table></figure>
<p>显然这里没有必要保留额外空间来表示基类对象. 上面说过, 为空对象保留空间的原因是保证其有唯一地址,
避免出现不同对象的地址相同的情形. 但是在这里, 子类地址就可以作为父类地址, 不会出现不同对象地址相同的情形.
但是即使是继承, 也有不能进行优化的情况:</p>
<ul>
<li>子类的第一个非静态数据成员的类型和空基类相同.</li>
<li>子类的第一个非静态数据成员的基类类型和空基类相同.</li>
</ul>
<p>不难看出, 这两种情况下, 会有两个空基类对象(父类对象和子类数据成员对象)连续出现, 如果优化掉,
将不能区别二者. 示例如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> Base <span class="comment">// 情况一</span></span><br><span class="line">&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="keyword">int64_t</span> i;</span><br><span class="line">&#125;d1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived3</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    Derived2 d2;</span><br><span class="line">    <span class="keyword">int64_t</span> i;</span><br><span class="line">&#125;d3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Derived1)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为16, 基类对象和成员b各占1 byte, 由于内存对齐补齐8 bytes</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Derived2)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Derived3)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为16, 基类对象和成员d2各占1 byte, 由于内存对齐补齐8 bytes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;d1&lt;&lt;<span class="string">' '</span>&lt;&lt;&amp;d1.b&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 前者(基类对象地址)比后者小1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;d3&lt;&lt;<span class="string">' '</span>&lt;&lt;&amp;d3.d2.b&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 前者(基类对象地址)比后者小1</span></span><br></pre></td></tr></table></figure>
<p>对于空类作为虚基类的情况, 同样可以进行优化. 例如下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> <span class="keyword">virtual</span> Base &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> <span class="keyword">virtual</span> Base &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived3</span> :</span> Derived1, Derived1 &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived4</span> :</span> Derived1, Derived1</span><br><span class="line">&#123;</span><br><span class="line">    Base b;</span><br><span class="line">&#125;d4;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Derived3)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为16</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(Derived4)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为24</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;d4&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为0x55c6986ffe70</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">dynamic_cast</span>&lt;Base*&gt;(&amp;d4)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为0x55c6986ffe70</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;(d4-&gt;b)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出为0x55c6986ffe80</span></span><br></pre></td></tr></table></figure>
<p>为了实现虚继承, 类Derived1和Derived2包含一个指针. 而虚基类Base被优化掉了, 因此Derived3大小为16 bytes.
而Derived4中由于包含类型是Base的非静态成员, 需要占据8 bytes, 即Derived4大小为24 bytes.
注意这里基类被优化了, 子类数据成员没有被优化. 测试显示, 即使这个成员不是第一个或最后一个, 编译器仍然不会优化.</p>
<p>虽然标准没有规定非静态数据成员在内存中的排列顺序, 但是一般实现都是按照声明顺序排列.
而由于内存对齐的要求, 仅仅改变成员的声明顺序可能产生不同大小的对象, 例如下面的声明:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span> // 大小为16 <span class="title">bytes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> i1;</span><br><span class="line">    <span class="keyword">char</span> c1; <span class="comment">// c1 和 c2 被放置在一个字(16 bytes)中</span></span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> // 大小为24 <span class="title">bytes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">int64_t</span> i1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test3</span> // 大小为16 <span class="title">bytes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> i1;</span><br><span class="line">    <span class="keyword">int32_t</span> i2; <span class="comment">// i2,c1,c2 被放置在一个字(16 bytes)中</span></span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于计算机是以字(32位机为4 bytes, 64位机为8 bytes)为单位来读写, 因此内存对齐可以加快存取操作.
否则当一个变量跨字时, 读取这个变量就需要两次内存读. 
但是这可能会增加需要的内存空间, 这就需要程序员仔细安排变量顺序, 以保证获得最佳的空间利用率.</p>
<p>而对于普通类的静态数据成员, 则具有独立于对象的静态生存期, 保存在全局数据段中.
模板类的静态数据成员如果没有被显式特化或实例化, 则在使用时会被隐式特化, 只有当特化/实例化后才是有效定义的.
有下面几种情况, 而这几种都可以归到C++14引入的 <em>variable template</em>(变量模板),
参考<a href="https://en.cppreference.com/w/cpp/language/variable_template" target="_blank" rel="noopener">cppreference</a>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> T val; <span class="comment">// 非模板类的模板静态成员.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T Test1::val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> T val; <span class="comment">// 模板类的非模板静态成员.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T Test2&lt;T&gt;::val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt; <span class="keyword">static</span> <span class="built_in">std</span>::pair&lt;T1, T2&gt; val; <span class="comment">// 模板类的模板静态成员.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;T1, T2&gt; Test2&lt;T1&gt;::val = <span class="built_in">std</span>::make_pair(T1(<span class="number">1</span>), T2(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> var = Test3&lt;<span class="keyword">int</span>&gt;::val&lt;<span class="keyword">float</span>&gt;; <span class="comment">// 即pair&lt;int, float&gt;(1, 2)</span></span><br></pre></td></tr></table></figure>
<h2 id="数据成员的存取"><a href="#数据成员的存取" class="headerlink" title="数据成员的存取"></a>数据成员的存取</h2><h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>对静态成员, 通过对象或对象指针访问和通过类名访问没有区别, 编译器一般会将二者统一为相同形式.
类成员指针不能指向静态成员, 因为对静态成员取地址得到的是一个该成员的指针. 如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;A::x; <span class="comment">// 其类型是 int*</span></span><br></pre></td></tr></table></figure>
<p>因为类静态成员都是保存在全局数据段中, 如果不同类具有相同名字的静态成员, 就需要保证不会发生名称冲突.
编译器的解决方法是对每个静态数据成员编码(这种操作称为name-mangling), 以得到一个独一无二的名称.</p>
<h3 id="非静态数据成员"><a href="#非静态数据成员" class="headerlink" title="非静态数据成员"></a>非静态数据成员</h3><p>不存在虚基类时, 通过对象名或对象指针访问非静态数据成员没有区别.
存在虚基类时, 通过对象指针访问非静态数据成员需要在运行时才能确定, 因为无法确定指针所指对象的实际类型, 也就不能判断对象的内存布局, 也就不知道对象中该数据成员的偏移.
普通继承和虚继承的这个区别的原因在于, 普通继承的类对象的内存布局在编译时就可以决定, 而存在虚继承时则需要在运行时决定, 详情见下文虚继承对内存布局的影响的讨论.</p>
<h2 id="继承对对象布局的影响"><a href="#继承对对象布局的影响" class="headerlink" title="继承对对象布局的影响"></a>继承对对象布局的影响</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>最简单的一种情况, 单继承不会修改父类的内存布局, 例如父类由于内存对齐产生的额外空间在子类中不会被消除, 而是保持原样.
所以下面的代码中, 子类大小是24 bytes, 而不是16 bytes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> // 16 <span class="title">bytes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> i1;</span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base <span class="comment">// 24 bytes</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其原因是如果消除了这些额外空间, 将子类对象赋值给父类对象时就可能会在父类对象的额外空间位置赋值, 这改变了程序的语义, 显然是不合适的.</p>
<h3 id="加上多态"><a href="#加上多态" class="headerlink" title="加上多态"></a>加上多态</h3><p>为了支持动态绑定, 编译器需要在对象中添加虚表指针(vptr), 指向虚表. 
虚表中包含类的类型信息和虚函数指针, 值得注意的是, vptr并不是指向虚表的起始地址, 很多时候该地址之前会保存着对象的类型信息, 程序通过此类型信息实现RTTI.
而vptr初值的设置和其所占空间的回收, 则分别由构造函数和析构函数负责, 编译器自动在其中插入相应代码. 这是多态带来的空间负担和时间负担.</p>
<p>那么vptr放在什么位置呢? 这是由编译器决定的, gcc将其放在对象头部, 这导致对象不能兼容C语言中的struct, 但是在多重继承中, 通过类成员指针访问虚函数会更容易实现.
如果放在对象末尾则可以保证兼容性, 但是就需要在执行期间获得各个vptr在对象中的偏移, 在多重继承中尤其会增加额外负担.</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>标准并没有规定不同基类在布局中的顺序, 但是大多数实现按照继承声明顺序安排. 多重继承给程序带来了这些负担:</p>
<ul>
<li><p>将子类地址赋值给基类指针变量时, 如果是声明中的第一个基类, 二者地址相等, 可以直接赋值. 否则, 需要加上一个偏移量, 已获得对应对象的地址.</p>
</li>
<li><p>上面的直接加偏移并不能保证正确性, 设想子类指针值为0, 直接加上偏移后指向的是一个内容未知的地址.
正确做法应该是将0值赋给基类指针变量. 因此, 需要先判断基类指针是否为0, 再做处理.
而对于引用, 虽然其底层是指针, 但是不需要检查是否为0, 因为引用必须要绑定到一个有效地址, 不可能为0.</p>
</li>
</ul>
<h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>主要问题是如何实现只有一个虚拟基类. 主流方案是将虚拟基类作为共享部分, 其他类通过指针等方式指向虚拟基类, 访问时需要通过指针或其他方式获得虚拟基类的地址.
gcc的做法是将虚基类放在对象末尾, 在虚表中添加一项, 记录基类对象在对象中的偏移, 从而获得其地址.
我们可以通过gdb调试来看看具体情况.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> i1 = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B::f() called\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> i2 = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> i3 = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D1, D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> i4 = <span class="number">4</span>;</span><br><span class="line">&#125;d3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">sizeof</span>(d3)/<span class="number">8</span>; ++i)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"d3["</span>&lt;&lt;i&lt;&lt;<span class="string">"] = 0x"</span>&lt;&lt;<span class="built_in">std</span>::hex&lt;&lt;*((<span class="keyword">int64_t</span>*)&amp;d3 + i)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>首先用g++编译, 载入gdb中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> g++ main.cc -g</span><br><span class="line"><span class="meta">#</span> gdb a.out</span><br></pre></td></tr></table></figure>
<p>之后, 设置断点, 运行程序, 再通过下面的命令查看对象d3的虚表.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p d3</span><br><span class="line">$2 = &#123;&lt;D1&gt; = &#123;&lt;B&gt; = &#123;_vptr.B = 0x555555557c58 &lt;vtable for D3+72&gt;, i1 = 1&#125;, _vptr.D1 = 0x555555557c28 &lt;vtable for D3+24&gt;, i2 = 2&#125;, &lt;D2&gt; = &#123; _vptr.D2 = 0x555555557c40 &lt;vtable for D3+48&gt;, i3 = 3&#125;, i4 = 4&#125;</span><br><span class="line">(gdb) p /a *((void**)0x555555557c28-3)@10</span><br><span class="line">$4 = &#123;0x28,</span><br><span class="line">      0x0,</span><br><span class="line">      0x555555557d20 &lt;_ZTI2D3&gt;,</span><br><span class="line">      0x18,</span><br><span class="line">      0xfffffffffffffff0,</span><br><span class="line">      0x555555557d20 &lt;_ZTI2D3&gt;,</span><br><span class="line">      0x0,</span><br><span class="line">      0xffffffffffffffd8,</span><br><span class="line">      0x555555557d20 &lt;_ZTI2D3&gt;,</span><br><span class="line">      0x555555555446 &lt;B::f()&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现, _vptr.D1等于*(int64_t *)&amp;d3, _vptr.D2等于*((int64_t *)&amp;d3 + 2), _vptr.B等于*((int64_t *)&amp;d3 + 5).
显然分别是各个对象的vptr的值. gdb的第二个命令是打印部分虚表内容, -3指定起始位置, 10指定长度.
可见_vptr.D1指向输出的第四个, _vptr.D2指向输出的第七个, 二者指向位置的地址减3即为对应对象和基类对象的偏移.
同样可以看到前一个是当前对象的类型信息. 如果在C++中直接访问虚表, 可以用下面的代码, 这和上面用gdb打印虚表等效:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> *vptr = (<span class="keyword">int64_t</span> *)*(<span class="keyword">int64_t</span> *)&amp;d3; <span class="comment">// D1的虚表地址.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-3</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"_vptr.D1["</span>&lt;&lt;i&lt;&lt;<span class="string">"] = 0x"</span>&lt;&lt;<span class="built_in">std</span>::hex&lt;&lt;*(vptr+i)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
        </div>
        <div id="post-footer">
            <div class="avatar" >
                <img src="https://avatars2.githubusercontent.com/u/12467961?s=400&u=ddd6df12f5ad2c663ba98c178343f1dd9d2ead20&v=4" alt="avatar"/>
                
                
            </div>
            <ul class="author-profile-section">
                <li>
                  
                  Author:
                  
                    
                    <a href="/about.html">oven yang</a>
                </li>
                
                <li>Published Date: <span>2018-10-19  00:00:00</span></li>
                
                <li>Updated Date: <span>2018-10-22  20:16:41</span></li>
                
                <li class="post-category">
                    Categories:
                    
                    <a href="/categories/深度探索C-对象模型笔记/">深度探索C++对象模型笔记</a>
                    
                </li>
                <li class="post-tags">
                    Tags:
                    
                    <a href="/tags/C/">C++</a>
                    
                </li>
                
                <li> License: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">
署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)
</a></li>
                
            </ul>
            <div id="donate-wrap">
                
                
                
                <img src="" alt="支付宝付款" class="donate-img">
                
                <img src="" alt="微信付款" class="donate-img">
                
                
            </div>
        </div>
    </article>
    <div class="article-nav">
        
        <a href="/深度探索C-对象模型笔记/inside-the-cpp-object-model-c4/" class="pre-post fa fa-caret-left">第4章 Function语意学</a>
        
        
        <a href="/深度探索C-对象模型笔记/inside-the-cpp-object-model-c2/" class="next-post fa">第2章 构造函数语意学</a>
        
    </div>
    
    <div id="comments">
        

<script>
  gitment.render(document.getElementById("comments"));
</script>



    </div>
    
</div>


    </div>
    <footer id="footer">
    
    <div>
        
        <a href="/" class="copyright-links">oven yang</a>&copy;2017 - 2019.All Rights
        Reserved.
    </div>
    <p>Powered by <a href="https://hexo.io" class="copyright-links" target="_blank">Hexo</a> | Theme by <a
                href="https://github.com/GeekaholicLin" class="copyright-links" target="_blank">GeekaholicLin</a>
    </p>
    
    
    <p>
        <span id="busuanzi_container_site_uv" class="fa fa-bar-chart">
        欢迎第 <span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span> 位小伙伴~
        </span>
    </p>
    
</footer>

</div>
    <ul id="tools">
    <li class="totop-btn fa fa-angle-up"></li>
    <li class="exchange-btn fa fa-exchange"></li>
  
    <li class="toc-btn fa fa-list-ul"></li>
    
    

    
</ul>
<p id="process"></p>
<div id="search-overlay">
    <div class="search-area-wrap">
        <div id="search-area">
            <div class="input-wrap focus">
                <i class="fa fa-search" aria-hidden="true"></i>
                <input id="search-input" autofocus autocomplete="off" type="text"
                       placeholder="search this website..."/>
            </div>
            <ul id="search-result">
                <li class="load-first"><i class="fa fa-spinner fa-pulse"></i></li>
            </ul>
        </div>
    </div>
</div>

    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#不含数据成员的类对象"><span class="toc-number">1.</span> <span class="toc-text">不含数据成员的类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据成员的存取"><span class="toc-number">2.</span> <span class="toc-text">数据成员的存取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态数据成员"><span class="toc-number">2.1.</span> <span class="toc-text">静态数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非静态数据成员"><span class="toc-number">2.2.</span> <span class="toc-text">非静态数据成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承对对象布局的影响"><span class="toc-number">3.</span> <span class="toc-text">继承对对象布局的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单继承"><span class="toc-number">3.1.</span> <span class="toc-text">单继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加上多态"><span class="toc-number">3.2.</span> <span class="toc-text">加上多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重继承"><span class="toc-number">3.3.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟继承"><span class="toc-number">3.4.</span> <span class="toc-text">虚拟继承</span></a></li></ol></li></ol>




<script src="/js/search.js"></script>
<script type="text/javascript">
    //theme config datas
    var copyrightObj = {};
    copyrightObj.enable = 'true';
    copyrightObj.triggerCopyLength = '200';
    copyrightObj.appendText = '商业转载请联系作者获得授权,非商业转载请注明出处 © example';
    var leancloudObj = {};
    leancloudObj.enable = 'true';
    leancloudObj.className = 'BlogCounter';
    leancloudObj.limits = '10';
</script>
<script type="text/javascript">
    var search = {};
    var search_path = "search.xml";
    if (!search_path) {
        search_path = "search.xml";
    }
    search.path = "/" + search_path;
    search.func =  _ajax.init();
</script>
<script src="/js/app.js"></script>


    <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
    <script>
        if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
        }
    </script>


</body>
</html>