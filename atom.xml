<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨文的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oven-yang.github.io/"/>
  <updated>2018-09-19T13:11:22.707Z</updated>
  <id>https://oven-yang.github.io/</id>
  
  <author>
    <name>oven yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文研读之Spinnaker</title>
    <link href="https://oven-yang.github.io/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/paper-spinnaker/"/>
    <id>https://oven-yang.github.io/论文研读/paper-spinnaker/</id>
    <published>2018-09-18T16:00:00.000Z</published>
    <updated>2018-09-19T13:11:22.707Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#motivation">Motivation</a></li><li><a href="#architecture">Architecture</a></li><li><a href="#replication-protocol">Replication Protocol</a><ul><li><a href="#写请求的处理">写请求的处理</a></li><li><a href="#读请求的处理">读请求的处理</a></li><li><a href="#leader选举">Leader选举</a></li></ul></li><li><a href="#recovery">Recovery</a><ul><li><a href="#follower-recovery">Follower Recovery</a></li><li><a href="#leader-takeover">Leader Takeover</a></li></ul></li></ul><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>可扩展性要求: 随着数据量增加, 要求增加新的设备存放数据. 一种做法就是将数据库按Key拆分, 分布在不同机器上, 每个机器负责一定Key范围内的数据. 而手动实现拆分繁琐, 容易出现问题. 所以需要一种架构支持拆分.容错性: 数据库保存在成百上千的普通机器上, 因此非常容易出现问题. 为了保证高可用性, 必须实现容错.</p><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><ul><li><p>基于Zookeeper, Paxos.</p></li><li><p>将数据库按Key拆分. 如Key为0-500, 可拆分为0-199, 200-399, 400-500三个范围, 分别包含对应的行.</p></li><li><p>使用3副本, 每个副本分别存放在不同机器上, 存放一个范围的多个机器称为一个cohort.不同范围的数据可以保存在同一机器上, 因此一个机器可以属于多个cohort.</p></li><li><p>log sequence number(LSN): 用于唯一标识cohort中的日志, 随日志单调递增.</p></li><li><p>一般情况下每个请求都是针对一行数据.</p></li></ul><h1 id="Replication-Protocol"><a href="#Replication-Protocol" class="headerlink" title="Replication Protocol"></a>Replication Protocol</h1><h2 id="写请求的处理"><a href="#写请求的处理" class="headerlink" title="写请求的处理"></a>写请求的处理</h2><ol><li>处理写请求W时, 请求首先被导向请求写的数据所属的cohort的Leader, Leader首先在日志中记录此请求, 然后, 在将日志写到磁盘的同时, 将W附加到commit queue的末尾, 并发送propose message到它的Follower.</li><li>Follower收到写请求时, 记录对应日志到磁盘, 在将W附加到commit queue末尾, 然后向Leader返回ack.</li><li>由于使用3副本, Leader只要收到一个ack就可以保证大多数的要求. 所以, 当收到一个ack时, Leader将W应用到memtable, 并commit W. 最后回复请求, 表明写请求执行成功.</li><li>Leader周期性地向Leader发送包含一个LSN值的commit message, 通知Follower将小于等于此LSN的log都commit. 节点记录最后提交的日志的LSN, 记为last committed LSN, 保存到磁盘中.</li></ol><h2 id="读请求的处理"><a href="#读请求的处理" class="headerlink" title="读请求的处理"></a>读请求的处理</h2><p>读数据时, 可以通过参数指明是strong consistency还是timeline consistency. 前者将向Leader请求数据, 后者可以向Follower请求数据, 以减小Leader的负载, 但是可能会读到旧数据.</p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>通过Zookeeper实现, 同一cohort的每个机器在相同目录下创建文件, 文件包含了自己的最后一个日志的LSN, 记为n.lst. 选择n.lst最大的节点作为Leader.</p><h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h1><h2 id="Follower-Recovery"><a href="#Follower-Recovery" class="headerlink" title="Follower Recovery"></a>Follower Recovery</h2><p>记 <strong>f.cmt</strong> 和 <strong>f.lst</strong> 分别代表节点日志中已commit的最后一个LSN和已保存的最后一个LSN.Follower恢复分为两个阶段:</p><ol><li>local recovery节点从最近的checkpoint重放小于等于f.cmt的日志, 节点便恢复到f.cmt对应的状态.</li><li>catch up节点向Leader发送f.cmt, Leader就可以确定节点的状态, 并向其发送f.cmt之后的日志记录.</li></ol><h2 id="Leader-Takeover"><a href="#Leader-Takeover" class="headerlink" title="Leader Takeover"></a>Leader Takeover</h2><p>当Leader节点发生错误时, 需要选举出新的Leader. 新的Leader必须包含所有之前的Leader已经commit的log. 选举策略如上所述.</p><p>但是可能存在这样的情况, 上一个leader fail后, 可能已经commit了部分write操作, 但是消息没有被其他follower接收到. 因此产生新的leader后, 它就要查看follower的最后commit的写操作是否落后于自己, 如果是, 就再次发送该写消息, 并通知folower commit. 当存在follower已经与leader同步, 就可以开始响应客户端的写操作.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#motivation&quot;&gt;Motivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#architecture&quot;&gt;Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#replication-protocol&quot;&gt;Rep
      
    
    </summary>
    
      <category term="论文研读" scheme="https://oven-yang.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
      <category term="分布式" scheme="https://oven-yang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>论文研读之GFS</title>
    <link href="https://oven-yang.github.io/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/paper-gfs/"/>
    <id>https://oven-yang.github.io/论文研读/paper-gfs/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T08:20:47.978Z</updated>
    
    <content type="html"><![CDATA[<p>GFS是谷歌内部使用的一种分布式文件系统.论文为: The Google File System</p><ul><li><a href="#assumption-and-motivation">Assumption and Motivation</a></li><li><a href="#架构">架构</a></li><li><a href="#master的功能">master的功能</a></li><li><a href="#chunkserver的任务">chunkserver的任务</a></li><li><a href="#操作日志operation-log和checkpoint">操作日志(Operation Log)和checkpoint</a></li><li><a href="#chunk-lease">chunk lease</a></li><li><a href="#文件读取">文件读取</a></li><li><a href="#append">Append</a></li><li><a href="#容错">容错</a></li><li><a href="#快照snapshot">快照(Snapshot)</a></li></ul><h1 id="Assumption-and-Motivation"><a href="#Assumption-and-Motivation" class="headerlink" title="Assumption and Motivation"></a>Assumption and Motivation</h1><ul><li>部件错误很常见.</li><li>文件非常大, GB大小的文件很常见.</li><li>绝大多数的文件修改操作是append, 也支持随机写.</li><li>读操作主要是顺序读取大量数据, 随机读取少量数据.</li><li>为多个客户端同时对同一文件append提供高效的同步支持, 保证append的原子性.</li><li>稳定的网络比低延迟更加重要.</li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><ul><li><p>一个master和很多chunkserver, 多个客户端可以并发访问, 见Figure 1. 显然存在单点故障问题.</p></li><li><p>一个文件被划分为多个固定大小的部分, 称为chunk, 每个chunk都有一个chunk handle唯一标识, 是在创建该chunk时由master分配的(由于只有一个master, 可以保证其唯一性).</p></li><li><p>每个chunk会被复制多份(一般是3份), 分散到不同chunkserver, 以保证容错. 由master选择其中一个chunk授权, 称为lease, 其余称为replica, 获得lease的chunk所在chunkserver控制了这些副本间的同步.</p></li><li><p>chunk由64KB大小的块组成, 称为block, 每个block在<em>内存</em>中有32bit的校验码. master记录了文件系统的所有状态, 文件名到对应chunk handle的映射, 所有chunk所在的chunkserver, 同一chunk中的lease, 等等。有的信息保存在磁盘, 有的只保存在内存中, 加快了这些信息的返回速度, 但是每次master重启时都需要询问chunkserver来获取这些信息(chunk所在服务器地址).</p></li><li><p>master定期和每个chunkserver联系, 以发送指令或获取信息. 客户端和master的交互只涉及控制信息, 状态信息等, 而没有数据. 数据直接在chunserver和客户端间流动, 减小了master的负载。</p></li><li><p>客户端不缓存数据, 但是客户端会缓存部分状态信息. 系统或其他部件实现的缓存不在讨论范围内. 在系统中, 很容易根据服务器的ip获取最佳路径.</p></li></ul><h1 id="master的功能"><a href="#master的功能" class="headerlink" title="master的功能"></a>master的功能</h1><ul><li>维护层次文件系统结构, 文件系统用<em>前缀树</em>来保存。</li><li>维护filename-chunk映射</li><li>记录每个chunk的位置</li><li>管理并发数据修改操作的顺序, 采用读写锁来实现同步。注意<em>GFS没有目录的概念</em>。</li><li>lease管理</li><li>检测, 处理失效chunk<ul><li>定期检查chunk是否有效, 无效则重复制以保证副本数量。</li><li>采用lazy deletion, 客户端请求删除chunk时, 并不立即删除chunk, 只是将其标记为无效, 定时删除这些chunk。</li></ul></li><li>复制chunk, 保证至少有3个副本, 或满足LB的需要, 当某个chunk成为瓶颈时, 会增加此chunk的副本数量。</li><li>副本位置迁移<ul><li>根据访问, 迁移副本的位置, 以提高带宽。</li><li>为了平衡chunkserver的数据量, 迁移副本。</li></ul></li></ul><h1 id="chunkserver的任务"><a href="#chunkserver的任务" class="headerlink" title="chunkserver的任务"></a>chunkserver的任务</h1><ul><li>保存chunk</li><li>同步对chunk的写操作</li></ul><h1 id="操作日志-Operation-Log-和checkpoint"><a href="#操作日志-Operation-Log-和checkpoint" class="headerlink" title="操作日志(Operation Log)和checkpoint"></a>操作日志(Operation Log)和checkpoint</h1><ul><li><p>checkpoint记录了某个时刻master的所有状态, master可以通过一个checkpoint恢复到那个时刻的状态.</p></li><li><p>操作日志记录了master的写操作.</p></li><li><p>先载入最近的checkpoint, 再重放此checkpoint之后的所有操作日志, 即可恢复master的状态. 因此, 采用日志先写的原则, 并将日志保存到磁盘中. master在日志达到一定大小后就建立checkpoint.</p></li></ul><h1 id="chunk-lease"><a href="#chunk-lease" class="headerlink" title="chunk lease"></a>chunk lease</h1><ul><li>由于每个chunk有多个副本, 因此在写chunk时, 需要考虑如何保证副本间的一致性. GFS使用了<em>Lease</em>的概念, 即授予一个chunk lease, 获得lease的chunk所在的服务器协调副本的写, 称此副本为primary. 这个想法最初是来自论文&lt;\&lt;Leases: An Efficient Fault-Tolerant Mechanism for Distributed File CacheConsistency.pdf&gt;&gt;.详细的写入步骤在<a href="#文件append">文件append</a>中.</li></ul><h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><p>下面是理想情况下的步骤:</p><ol><li>client根据文件偏移计算对应chunk号, 向master发送消息询问chunk地址, 消息包含: 文件名,chunk号.</li><li>master返回：chunk handle, chunk所在服务器ip列表(因为有多个副本).</li><li>client根据ip计算最近服务器, 发送消息请求数据。消息包含: chunk handle, 要读取的数据范围(byte range).</li><li>chunkserver返回数据.</li></ol><p>之后一段时间client会缓存该chunk的地址, 再次读取chunk时不需要与master交互。</p><h1 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h1><p>下面是理想情况下的步骤:</p><ol><li>client询问要append的chunk的primary及其地址。</li><li>master如果发现此chunk还没有授予lease, 就选择一个授予lease. 返回primary和其他副本(secondary)的地址.</li><li>client通过所有副本的ip地址, 计算出<em>一条</em>分发数据的路径, 然后推送数据. 中间收到数据的副本所在服务器在收到部分数据后就立即向其他副本所在服务器转发. 而不是等到所有数据都受到后才转发.收到的数据被还没有写入.</li><li>副本所在服务器收到数据后, 向client返回ack, 并包含一个id以标记此数据.</li><li>client收到所有副本的ack之后, 向primary请求开始写入. 请求中必须包含此数据的id(副本返回的).</li><li>primary收到写入请求, 尝试写入, 如果成功就为之赋予一个序号, 以此将所有写入序列化, 并将请求转发到secondary. 如果失败则向client返回错误, return.</li><li>secondary完成写入后, 回复primary.</li><li>当primary收到所有secondary的写入成功回复后, 即回复写入成功. 否则返回写入失败.</li></ol><h1 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h1><ul><li><p>当append时, primary写入失败, 如何处理?</p><p>此时primary chunk有错误数据, 而secondary对应区域没有数据, 关键就是保证副本间的一致性.GFS的处理简单粗暴, 放弃这个区域, 重新选择一个区域append.</p></li><li><p>那么又有问题了, 再之后顺序读取中, 如何识别区域是无效的呢?</p><p>好像文章里没有说, 不过实现起来应该很简单. 因为有检验码, 或者有其他标志.</p></li><li><p>如果primary成功, 某些secondary失败呢?</p><p>  参照上面的方法处理.</p></li><li><p>在chunkserver向客户端或其他chunkserver返回数据时, 都会检查每个chunk的校验码, 防止错误数据扩散.</p></li><li><p>master的状态会复制到多个机器上, 这些机器作为备份。操作日志会保证先写到这些备份机器上再在master执行. master重启速度非常快, 并且从各个chunkserver获取chunk位置的速度也很快.</p></li></ul><h1 id="快照-Snapshot"><a href="#快照-Snapshot" class="headerlink" title="快照(Snapshot)"></a>快照(Snapshot)</h1><p>复制一个文件/目录, 采用copy-on-write策略. 因此每个文件有一个引用计数, 当修改引用计数超过1的文件时, 需要将其复制一份才能修改.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GFS是谷歌内部使用的一种分布式文件系统.
论文为: The Google File System&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#assumption-and-motivation&quot;&gt;Assumption and Motivation&lt;/a&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="论文研读" scheme="https://oven-yang.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
      <category term="分布式" scheme="https://oven-yang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>论文研读之Zab协议</title>
    <link href="https://oven-yang.github.io/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/paper-zab/"/>
    <id>https://oven-yang.github.io/论文研读/paper-zab/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T11:40:50.760Z</updated>
    
    <content type="html"><![CDATA[<p>Zab是ZooKeeper中使用的用来保证可用性和一致性的协议.论文为: A simple totally ordered broadcast protocol</p><ul><li><a href="#zookeeper对广播协议的要求">ZooKeeper对广播协议的要求:</a></li><li><a href="#two-types-of-causal-relationships">Two types of Causal Relationships</a></li><li><a href="#recovery">Recovery</a></li><li><a href="#broadcast">Broadcast</a></li></ul><p>写请求都通过一个leader服务器来执行, 这样就可以将非幂等(non-idempotent)的请求转化为幂等(idempotent)的请求.读请求可以在客户端直接连接的服务器执行, 但是返回的数据可能陈旧的或无效的, 当然, 可以通过参数指明采用同步读以从leader读取最新数据.</p><h1 id="ZooKeeper对广播协议的要求"><a href="#ZooKeeper对广播协议的要求" class="headerlink" title="ZooKeeper对广播协议的要求:"></a>ZooKeeper对广播协议的要求:</h1><ul><li><p><strong>Reliabl delivery</strong>: If a message, <em>m</em>, is delivered by one server, then itwill be eventually delivered by all correct servers.</p></li><li><p><strong>Total order</strong>: If a message <em>a</em> is delivered before message <em>b</em> by oneserver, then every server that delivers <em>a</em> and <em>b</em> delivers <em>a</em> before <em>b</em>.</p></li><li><p><strong>Causal order</strong>: If a message <em>a</em> causally precedes message <em>b</em> and both messages are delivered, then <em>a</em> must be ordered before <em>b</em>.</p></li><li><p><strong>Prefix property</strong>: If <em>m</em> is the last message delivered for a leader <em>L</em>,any message proposed before <em>m</em> by <em>L</em> must also be delivered.</p></li></ul><h1 id="Two-types-of-Causal-Relationships"><a href="#Two-types-of-Causal-Relationships" class="headerlink" title="Two types of Causal Relationships"></a>Two types of <strong>Causal Relationships</strong></h1><ul><li><p>If two messages, <em>a</em> and <em>b</em>, are sent by the same server and <em>a</em> is proposedbefore <em>b</em>, we say that <em>a</em> causally precedes <em>b</em>;</p></li><li><p>Zab assumes a single leader server at a time that can commit proposals. If aleader changes, any previously proposed messages causally precedes messagesproposed by the new leader.</p></li></ul><p>Zab中没有特别说明如何实现leader选举, 主要包含两部分内容:</p><ul><li><strong><a href="#recovery">recovery</a></strong>: 当服务刚刚启动或leader fail后, 就进入recovery mode.</li><li><strong><a href="#broadcast">broadcast</a></strong>: 当产生新的leader, 并且leader已与大多数服务器同步, 即可开始broadcast.</li></ul><h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h1><p>当服务刚开始或发生leader failure之后, Zab就进入recovery mode, 直至产生新的leader, 并且leader和大多数follower的状态已同步. 而完成这两个步骤之后, leader就可以广播消息.</p><p>选举新的leader时, 需要保证发生fail之前的消息不能被遗忘, 因此规定选举新选举的leader必须具有最高的proposal number. 这样还可以避免新的leader向follower同步proposal.</p><p>另一种情况是上一轮被丢弃的消息由于延迟, 在选举出新的leader后出现, 必须保证能够正确丢弃这些proposal. 解决办法是为proposal赋予一个 <strong>zxid</strong>, 假设为64bit, 高32bit作为 <strong>epoch</strong>,低32bit作为计数器. 每次选举出一个leader, 就产生一个新的 <strong>epoch number</strong>, 并重置计数器为0.所有的proposal都会附带当前leader产生的epoch number和计数器. 这样, 即可通过epoch number识别proposal是否是陈旧的.</p><h1 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h1><p>使用简化版本的两步提交(2-phase commit, 2PC), 由leader向follower发出proposal, follower收到proposal时, 将其记录到磁盘, 但并不commit, 并向leader返回ack. 当leader收到大多数follower的ack时, 即可commit该proposal, 并向follower发送COMMIT消息, 表明可以commit该proposal.</p><p>broadcast使用的是FIFO信道(FIFO channel), 基于TCP即可实现, 这样就能保证消息的有序性.</p><p>leader会为每个proposal消息附带一个zxid, 详情见上文<a href="#recovery">recovery</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Zab是ZooKeeper中使用的用来保证可用性和一致性的协议.
论文为: A simple totally ordered broadcast protocol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#zookeeper对广播协议的要求&quot;&gt;ZooKeeper对广播协
      
    
    </summary>
    
      <category term="论文研读" scheme="https://oven-yang.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
      <category term="分布式" scheme="https://oven-yang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>论文研读之ZooKeeper</title>
    <link href="https://oven-yang.github.io/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/paper-zookeeper/"/>
    <id>https://oven-yang.github.io/论文研读/paper-zookeeper/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T08:14:03.409Z</updated>
    
    <content type="html"><![CDATA[<p>论文为: ZooKeeper: Wait-free coordination for Internet-scale systems</p><ul><li><a href="#description">Description</a></li><li><a href="#原子广播atomic-broadcast">原子广播(atomic broadcast)</a></li><li><a href="#replicated-database">Replicated Database</a></li><li><a href="#client-server-interactions">Client-Server Interactions</a></li></ul><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>ZooKeeper是为分布式应用提供的协调服务的组件, 想法源于谷歌的chubby, 在其上做了很多修改.</p><p>ZooKeeper具有一下特征:</p><ul><li>采用事件驱动机制, 因此能提供 <strong>wait-free</strong> 的接口.</li><li>高可用性, 相比chubby, 更加注重效率.</li><li>对于同一客户端的请求, 能保证FIFO地执行.</li><li>对于所有改变ZooKeeper状态的请求, 能保证全局有序.</li></ul><p>ZooKeeper采用专门设计的 <strong>原子广播协议(<em>atomic broadcast protocol</em>)</strong> — <strong>Zab</strong>来保证一致性.</p><p>改变ZooKeeper状态的请求都通过master顺序处理, 读请求则可以通过follower处理, 这是保证ZooKeeper高效率的关键.</p><h1 id="原子广播-atomic-broadcast"><a href="#原子广播-atomic-broadcast" class="headerlink" title="原子广播(atomic broadcast)"></a>原子广播(atomic broadcast)</h1><p>由原子广播保证server间的一致性, 提供fail-over.在文章<a href="/论文研读/paper-zab/" title="论文研读之Zab协议">论文研读之Zab协议</a>里有总结.</p><p>详情可以参考:</p><ul><li>A simple totally ordered broadcast protocol —简单介绍了Zab.</li><li>Zab: High-performance broadcast for primary-backup systems —相比上一篇更加详细.</li></ul><h1 id="Replicated-Database"><a href="#Replicated-Database" class="headerlink" title="Replicated Database"></a>Replicated Database</h1><p>ZooKeeper周期性地创建快照(snapshots), 复制自身的状态, 但是创建快照时并不对整个文件系统加锁,而是深度遍历所有节点, 原子地复制所有节点. 这就导致最后的快照可能不对应任何一个有效状态,  即节点间状态不一致. 但是由于所有的写操作都是idempotent的, 所以只需要重放在开始创建快照时刻之后的写操作, 即可使快照有效.</p><h1 id="Client-Server-Interactions"><a href="#Client-Server-Interactions" class="headerlink" title="Client-Server Interactions"></a>Client-Server Interactions</h1><p>client可以连接到ZooKeeper中的任何一个server, 与server建立session后, 即可向其发送请求.对于读请求, 可以由server在本地处理, 并在回复中附带zxid, 以表明当前server的状态.对于写请求, 如果server不是master, 就需要将请求转发到master, 由master处理, 再返回给client.</p><p>读请求的处理方式会导致client读到的数据可能是无效的, 如果client需要保证一定读取最新的数据,ZooKeeper提供sync接口, client通过调用sync通知连接的server与master同步状态, 同步完成后再读取数据即可获得最新数据.</p><p>ZooKeeper规定, 当client连接到一个新的server时, 必须保证此server的zxid &gt;= client最后请求的zxid. 即server的状态不能落后的client观察到的最新的状态. 这对于保证durability非常重要.</p><p>ZooKeeper使用超时机制检测session failure, 设超时时间为session timeout, 建立session的client为session client.</p><ul><li><p>当master发现在session timeout内ZooKeeper没有收到session client的请求时, 即认为发生了failure. 因此, 客户端必须在一定时间内发送消息给server, 如果没有请求时, 则需要发送heartbeat消息.</p></li><li><p>设session timeout为s, 那么当session在 s/3 时间内没有消息时, client向server发送heartbeat消息, 在 2s/3 时间内没有收到回复时, 与其他server尝试建立session. 这样做是为了防止当server发生failure, 导致master认为client长时间没有发送消息, 而将session关闭.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文为: ZooKeeper: Wait-free coordination for Internet-scale systems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="论文研读" scheme="https://oven-yang.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
      <category term="分布式" scheme="https://oven-yang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>论文研读之Chubby</title>
    <link href="https://oven-yang.github.io/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/paper-chubby/"/>
    <id>https://oven-yang.github.io/论文研读/paper-chubby/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T08:09:10.454Z</updated>
    
    <content type="html"><![CDATA[<p>Chubby是谷歌提出的在分布式环境下方便节点间的协调的服务.论文为: The Chubby lock service for loosely-coupled distributed systems</p><ul><li><a href="#motivation">Motivation</a></li><li><a href="#design">Design</a></li><li><a href="#architecture">Architecture</a></li><li><a href="#files-directories-and-handles">Files, directories, and handles</a></li><li><a href="#locks-and-sequencers">Locks and sequencers</a></li><li><a href="#events">Events</a></li><li><a href="#caching">Caching</a></li><li><a href="#sessions-and-keepalives">Sessions and KeepAlives</a></li><li><a href="#fail-overs">Fail-overs</a></li></ul><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul><li>为primary election问题提供通用的解决方案, 不需要特别实现和人工干预.</li><li>为客户端提供 <strong>粗粒度</strong> 的同步, 协调服务, 解决客户端的共识问题.</li><li>可靠性和可用性, 支持大量客户端.</li><li>语义简单, 易于使用.</li><li>不要求提供高吞吐率.</li></ul><h1 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h1><ul><li>对外提供锁服务来说实现客户端间的协调, 比如客户端leader选举问题, 客户端向chubby申请获取锁,获得锁的客户端即为leader. 这样可以保证即使只有一个客户端可用时, 客户端系统仍然可用. 这就相当于将部分保证一致性的任务转移到了chubby.</li><li>leader通过将信息写到小文件中来向其他节点广播消息.</li><li>客户端数量可能非常多, 因此需要允许大量客户端observe(观察?)上面提到的小文件, 并且不需要在chubby端部署很多服务器.</li><li>客户端可能希望当观察的文件发生变化时得到通知, 因此可以使用事件通知机制, 在客户端订阅的事件发生时向其发送通知, 减少客户端的polling.</li><li>需要支持 <strong>consistent caching</strong> 和访问控制.</li><li>使用粗粒度的锁(coarse-grained lock), 因为实际中客户端持有锁的时间可能达到几小时甚至几天,并且锁请求的数量与事务的数量是弱相关的. 并且, 锁从一个客户端转移到另一个客户端的代价很大, 所以不希望chubby服务的崩溃-恢复丢失对原来锁的记录, 导致客户端服务器重新获取锁.</li></ul><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><ul><li>chubby包含两部分: 服务器集群和库, 二者通过RPC通讯. 库可以与客户端应用链接, 为客户端提供接口.</li></ul><p><img src="/images/chubby-architecture.png" alt="chubby架构"></p><ul><li><p>服务器集群通过一致性算法选举出leader, 并获得一个leader lease, 副本服务器在lease内不会选举新的leader, lease可以由副本服务器定时更新(怎么实现的?怎么进行协商?), 以延长此lease. 副本服务器维护数据库的副本, 由master控制对数据库的读写, 副本服务器仅仅是按照master的要求更新数据库?(什么意思? 只由master负责响应客户端的对请求吗?)</p></li><li><p>DNS保存了chubby服务器集群的地址列表, 客户端通过向表中的机器发送 <strong>master location request</strong>来获得master的地址, 副本服务器将会返回master的位置(地址?).客户端获得master的位置后, 将所有请求发送到master, 直到master停止回复(cease to respond,什么意思?)或声明不再是master.对于写请求, master将其通过一致性协议发送到所有副本服务器, 当大多数副本ack后, master即可向客户端发送ack. (<em>如果在这个阶段master lease到期, 怎么处理?</em>)对于读请求, 由master直接回复.</p></li><li><p>如果一个副本服务器崩溃, 并且数个小时没有恢复, <strong>replacement system</strong> 就会在从空闲机器池中选择一个新的机器来代替它, 并更新DNS. master周期性地检查DNS, 发现这个更改后, 将此更新更新到集群所有服务器的数据库中.同时, 新的副本服务器通保存在文件服务器的备份和其他活动副本服务器(active replicate)的更新来获得最近的数据库副本. 一旦这个新的副本服务器处理了一个当前master等待commit的请求, 即可参与到将来的master选举, 在此之前不允许其参与.</p></li></ul><h1 id="Files-directories-and-handles"><a href="#Files-directories-and-handles" class="headerlink" title="Files, directories, and handles"></a>Files, directories, and handles</h1><ul><li><p>chubby向客户端提供了一个类似Unix文件系统接口的接口, 逻辑上对外的数据结构是一个树状的文件系统. 文件系统由文件和目录组成, 一个目录可以称为一个chubby cell, 作为一个独立的单位, 在cell下可以进行如文件删除创建等操作.</p></li><li><p>文件和目录统称为node. 每个node都有很多<strong>元数据</strong>(meta-data).</p><ul><li>3个ACL(access control list)名字, 分别用来控制对node的读, 写权限和修改ACL名字权限, 这些名字分别对应了此cell中权限控制目录下的一个目录, 比如node abc写权限的名字为abc_wr, 那么abc所在cell的权限控制目录下有一个目录abc_wr, abc_wr下的文件的名字就对应着一个对abc有写权限的用户名. node可以是永久(permant)的或临时(ephemeral)的, 每个node可以被显式地删除, 对于临时节点, 满足某些条件时会被自动删除. 比如没有客户端保持对临时节点的打开, 临时目录下为空(目录下没有node). 经常用一个临时文件表示客户端是否存活.</li><li>an instance number</li><li>a content generation number(files only)</li><li>a lock generation number</li><li>an ACL generation number</li></ul></li><li><p>成功打开一个node后可以获得一个handle, 以后可以用这个handle来对文件进行各种操作, 类似Unix中的文件描述符. Unix中, 只有打开文件描述符时才会进行权限检查, 以后对fd调用操作函数时不会检查权限, 但在chubby中, 会对每个操作进行权限检查.chubby周期性地检查打开文件/持有锁的客户端是否alive, 当发现客户端已经fail时, 会自动进行相应处理.handle同样包含元数据:</p><ul><li>check digits: 防止恶意客户端猜测, 非法创建handle.</li><li>a sequence number: master可以通过这个判断此handle是由自己生成还是之前的master生成的.</li><li>mode information: provided at open time to allow the master to recreate itsstate if an old handle is presented to a newly restarted master.(当一个master fail-over之后, 收到一个fail-over前创建的handle, 可以用此handle的mode information<em>重建自己的状态</em>?)</li></ul></li></ul><h1 id="Locks-and-sequencers"><a href="#Locks-and-sequencers" class="headerlink" title="Locks and sequencers"></a>Locks and sequencers</h1><ul><li>每个node都可以作为一个读写锁, 注意, 这里使用的是advisory lock.</li><li><strong>消息乱序问题</strong>:客户端C0获取锁L, 发送一个请求R, R到达之前C0崩溃, 客户端C1获取锁L, 之后, R到达, 由于使用的是advisory lock, 因此请求R将被执行. 显然这是非法的. 因此必须保证消息的处理顺序和每个参与者观察到的顺序一致.(参与者? 观察到的顺序?) 可以注意到, 这里消息乱序的仅仅指不同客户端的的消息乱序, 不包括同一客户端发出的消息. 解决办法是为每个成功的锁请求分配一个 <strong>sequencer</strong>, 包含锁的名字, 类型(r/w)和上文提到的lock generation number. 客户端发出请求时附带此sequencer, chubby通过验证sequencer来判断顺序是否正确.</li></ul><h1 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h1><p>客户端创建了handle后, 可以订阅一系列事件, 在相应事件发生时, 客户端会收到通知.</p><h1 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h1><p>客户端可以缓存文件数据和元数据(meta-data), 为保证缓存一致性, 当chubby要对数据写时, 首先检查数据是否被客户端缓存, 如果是, 那么先向客户端发送命令, 是客户端将其缓存标记为无效, 命令成功后再进行写操作.</p><p>不仅如此, 客户端还可以缓存打开的handle, 所以当客户端多次调用open打开一个文件时, 只需要第一次将请求发送到chubby集群.</p><p>客户端可以缓存锁. 当有其他客户端请求该锁时, 客户端会收到通知, 已执行相应动作, 如释放锁.</p><h1 id="Sessions-and-KeepAlives"><a href="#Sessions-and-KeepAlives" class="headerlink" title="Sessions and KeepAlives"></a>Sessions and KeepAlives</h1><p>客户端和chubby cell间的连接称为session, 客户端第一次联系cell或master时, 可以请求一个session,session通过周期性的KeepAlives消息来维护, 客户端可以主动结束session.下面主要讨论session的维持:</p><p>每个session都有一个lease, 在lease未超时前chubby保证session的有效性. 当客户端建立一个session时, 立即向cell发送一个KeepAlive请求, cell并不会立即回复, 而是估计lease即将超时时才会回复,回复可以延长此lease一定时间, 客户端收到此回复时又立刻发送新的KeepAlive请求, 后面的步骤如上.</p><p>lease在下面3种情况下可以被延长:</p><ul><li>on creation of session</li><li>when a master fail-over occurs</li><li>when a master responses to a KeepAlive RPC from client</li></ul><p>KeepAlive消息附带其他的信息, 比如通知客户端使缓存无效的事件等.</p><p>当lease超时, 即客户端没有及时收到chubby的KeepAlive回复时, lease处于jeopardy, 客户端无法确定此时session的状态, 因此会将缓存标记为无效, 等待chubby的KeepAlive回复. 此状态会持续一段时间, 这段时间称为grace period. 如果在此时间内客户端和chubby成功交换了一轮KeepAlive消息,就会恢复缓存, 开始新的lease, chubby library会向客户端应用发送一个<em>safe event</em>. 如果graceperiod超时, 则向客户端应用发送一个<em>expired event</em>.</p><h1 id="Fail-overs"><a href="#Fail-overs" class="headerlink" title="Fail-overs"></a>Fail-overs</h1><ul><li>master fail后恢复session</li></ul><p>如上所述, 如果chubby能在lease超时前或grace peroid超时前选举新的leader, 恢复session等数据到内存中, 客户端只需要通过和新的master通信即可继续维护session.</p><ul><li>新master状态恢复</li></ul><p>可以从下面几个方向重建状态:</p><ul><li>通过记录的磁盘的数据</li><li>通过从客户端获取的数据</li><li>通过客户端的消息中包含的数据(如打开的handle名)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Chubby是谷歌提出的在分布式环境下方便节点间的协调的服务.
论文为: The Chubby lock service for loosely-coupled distributed systems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#motivation&quot;&gt;M
      
    
    </summary>
    
      <category term="论文研读" scheme="https://oven-yang.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    
      <category term="分布式" scheme="https://oven-yang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>第1章 关于对象</title>
    <link href="https://oven-yang.github.io/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/inside-the-cpp-object-model-c1/"/>
    <id>https://oven-yang.github.io/深度探索C-对象模型笔记/inside-the-cpp-object-model-c1/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2018-09-19T13:14:03.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><ul><li><p>简单对象模型(A Simple Object Model)</p><p>对象直接保存成员的值. C++中采用的就是这种方法.</p></li><li><p>表格驱动对象模型(A Table-driven Object Model)</p><p>对象中的每个成员对应一个指针, 指针指向成员实际的值. C++虚表采用这种方法实现.</p></li></ul><h1 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h1><p>每个有虚函数的类产生一个virtual table, 保存所有虚函数的指针, 对象在所在内存开始位置保存指向vtable的指针vptr.在调用类的虚函数时, 会沿着虚函数表搜索, 第一个满足条件的就是要调用的函数.</p><p>单继承且无继承时, 每个对象只有一个vptr, 而当存在虚继承时, 虚继承的直接子类还会产生一个附加的vptr, 指向自身的virtual table. 当存在多继承时, 会为每个父类产生一个vptr. 下面针对这些情况详细举例说明.</p><ul><li><p>单继承, 无虚继承时的对象模型</p><p>这是最简单的情况, 在对象的开始处保存一个vptr指针, 指向一个虚函数指针数组, 非静态数据成员按继承, 声明的顺序排列.</p></li><li><p>单继承, 有虚继承时的对象模型</p><p>采用虚继承的类会在产生多个vptr, 对象开始处是父类的vptr, 父类成员之后, 子类成员之前保存子类的vptr. 如下:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> m_bb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> BB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_b1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DD</span> :</span> <span class="keyword">public</span> B1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> DD</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_d1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// D1对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span></span><br><span class="line">&#123;</span><br><span class="line">    &lt;DD&gt; =</span><br><span class="line">    &#123;</span><br><span class="line">        &lt;B1&gt; =</span><br><span class="line">        &#123;</span><br><span class="line">            &lt;BB&gt; =</span><br><span class="line">            &#123;</span><br><span class="line">                _vptr.BB = &lt;vtable <span class="keyword">for</span> D1+<span class="number">112</span>&gt;, <span class="comment">// 父类的vptr</span></span><br><span class="line">                m_bb</span><br><span class="line">            &#125;,</span><br><span class="line">            _vptr.B1 = &lt;vtable <span class="keyword">for</span> D1+<span class="number">24</span>&gt;, <span class="comment">// 虚继承子类B1的vptr</span></span><br><span class="line">            m_b1</span><br><span class="line">        &#125;,</span><br><span class="line">        m_dd</span><br><span class="line">    &#125;,</span><br><span class="line">    m_d1 <span class="comment">// 没有采用虚继承, 因此与基类BB共用vptr.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多继承, 无虚继承时的对象模型</p><p>保留多个父类的vptr.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> m_bb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> <span class="keyword">public</span> BB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_b1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> <span class="keyword">public</span> BB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_b2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DD</span> :</span> <span class="keyword">public</span> B1, B2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span></span><br><span class="line">&#123;</span><br><span class="line">    &lt;B1&gt; =</span><br><span class="line">    &#123;</span><br><span class="line">        &lt;BB&gt; =</span><br><span class="line">        &#123;</span><br><span class="line">            _vptr.BB = &lt;vtable <span class="keyword">for</span> DD+<span class="number">16</span>&gt;, <span class="comment">// B1的vptr</span></span><br><span class="line">            m_bb</span><br><span class="line">        &#125;,</span><br><span class="line">        m_b1</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;B2&gt; =</span><br><span class="line">    &#123;</span><br><span class="line">        &lt;BB&gt; =</span><br><span class="line">        &#123;</span><br><span class="line">            _vptr.BB = &lt;vtable <span class="keyword">for</span> DD+<span class="number">80</span>&gt;, <span class="comment">// B2的vptr</span></span><br><span class="line">            m_bb</span><br><span class="line">        &#125;,</span><br><span class="line">        m_b2</span><br><span class="line">    &#125;,</span><br><span class="line">    m_dd <span class="comment">// 与基类B1共用vptr.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BB *bp = <span class="keyword">new</span> DD; <span class="comment">// 错误, 有歧义</span></span><br><span class="line">BB *bp1 = <span class="keyword">dynamic_cast</span>&lt;B1*&gt;(<span class="keyword">new</span> DD); <span class="comment">// 正确, bp1指向DD中的B1部分.</span></span><br><span class="line">BB *bp2 = <span class="keyword">dynamic_cast</span>&lt;B2*&gt;(<span class="keyword">new</span> DD); <span class="comment">// 正确, bp2指向DD中的B2部分.</span></span><br></pre></td></tr></table></figure><p>很自然地, 当用BB类型的指针/引用保存DD对象时, 就会出现歧义, 编译器无法确定采用B1中的BB还是B2中BB. 可以使用 dynamic_cast 进行干预, 以达到预期目的.</p></li><li><p>多继承, 有虚继承时的对象模型</p><p>  有了上面的结论, 就不难推测这种情况下的对象模型了.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> m_bb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> BB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_b1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> BB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_b2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DD</span> :</span> <span class="keyword">public</span> B1, B2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> m_dd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// DD对象的结构, gcc 8.2.0, GNU gdb 8.1.1</span></span><br><span class="line">&#123;</span><br><span class="line">    &lt;B1&gt; =</span><br><span class="line">    &#123;</span><br><span class="line">        &lt;BB&gt; =</span><br><span class="line">        &#123;</span><br><span class="line">            _vptr.BB = &lt;vtable <span class="keyword">for</span> DD+<span class="number">160</span>&gt;,</span><br><span class="line">            m_bb = <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        _vptr.B1 = &lt;vtable <span class="keyword">for</span> DD+<span class="number">24</span>&gt;,</span><br><span class="line">        m_b1</span><br><span class="line">    &#125;,</span><br><span class="line">    &lt;B2&gt; =</span><br><span class="line">    &#123;</span><br><span class="line">        _vptr.B2 = &lt;vtable <span class="keyword">for</span> DD+<span class="number">88</span>&gt;,</span><br><span class="line">        m_b2</span><br><span class="line">    &#125;,</span><br><span class="line">    m_dd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="关键字class和struct的区别"><a href="#关键字class和struct的区别" class="headerlink" title="关键字class和struct的区别"></a>关键字class和struct的区别</h1><p>二者在绝大多数情况下是完全相同的, 可以互换, 只有几点不同.</p><p>class可以用于模板声明, struct不可以. C++引入class关键字, 保留struct的一个原因是为了体现OO,并且兼容C, 而C中不需要模板, 也就不需要保证struct可以用于模板.</p><p>另外, 当用于声明类类型时二者略有差别:</p><ul><li><p>用class声明的类的成员的默认访问级别是private, 用struct声明的类的成员的默认访问级别是public.</p></li><li><p>有继承时, 用class声明的类的默认继承方式是private, 用struct声明的类的默认继承方式是public.这里的class, struct是指用于子类, 父类的声明方式不影响默认方式. 如下代码:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> BB &#123;&#125;; <span class="comment">// private继承</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> BB &#123;&#125;; <span class="comment">// public继承</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="运行时多态必须通过public继承实现"><a href="#运行时多态必须通过public继承实现" class="headerlink" title="运行时多态必须通过public继承实现"></a>运行时多态必须通过public继承实现</h1><p>这个设计是符合逻辑的. 可以设想, 如果使用其他继承方式, 那么从逻辑上说, 在类外不应该能访问父类成员. 但是要实现运行时多态, 正常做法是将子类指针/引用赋值给一个父类类型的指针/引用(设为bp), 一旦复制成功, 我们就可以通过bp访问父类的public成员, 这显然与前面的逻辑要求矛盾. 所以, 在C++中,前面说得”赋值”是违法的. 而没有这个”赋值”操作, 也就无法实现运行时多态, 因此必须通过public继承实现运行时多态.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象模型&quot;&gt;&lt;a href=&quot;#对象模型&quot; class=&quot;headerlink&quot; title=&quot;对象模型&quot;&gt;&lt;/a&gt;对象模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单对象模型(A Simple Object Model)&lt;/p&gt;
&lt;p&gt;对象直接保存成员的值. C++中
      
    
    </summary>
    
      <category term="深度探索C++对象模型笔记" scheme="https://oven-yang.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://oven-yang.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>对象初始化的方法</title>
    <link href="https://oven-yang.github.io/C/object-initilize-methods/"/>
    <id>https://oven-yang.github.io/C/object-initilize-methods/</id>
    <published>2017-11-07T16:00:00.000Z</published>
    <updated>2018-09-19T13:13:42.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初始化的含义"><a href="#初始化的含义" class="headerlink" title="初始化的含义"></a>初始化的含义</h1><p>所谓初始化，就是给一个变量一个初始值，在使用一个变量的值之前，需要对其进行初始化，否则，得到的就</p><p>是一个无意义的值。</p><h1 id="初始化的方法"><a href="#初始化的方法" class="headerlink" title="初始化的方法"></a>初始化的方法</h1><h2 id="用圆括号：type-var-expression-list"><a href="#用圆括号：type-var-expression-list" class="headerlink" title="用圆括号：type var(expression-list)"></a>用圆括号：<strong>type var(expression-list)</strong></h2><p>圆括号中是我们提供给构造函数的参数，看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">1</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span> </span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="built_in">string</span> s ;</span><br><span class="line">    MyClass();</span><br><span class="line">    MyClass(<span class="keyword">int</span> , <span class="keyword">const</span> <span class="built_in">string</span>&amp;) ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">1</span> , <span class="string">"hello"</span>)</span> </span>;</span><br></pre></td></tr></table></figure><p>这是一种显示初始化的方式，相当于主动调用对应类型的构造函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">1.1</span>)</span> </span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">1.1</span> , <span class="string">"hello"</span>)</span> </span>;</span><br></pre></td></tr></table></figure></p><p> 注意，如果想采用默认初始化方式初始化一个变量，下面的做法是错误的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure></p><p>因为编译器会将其看作是函数声明，而不是变量定义。正确的做法应该1是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> ii&#123;&#125; ;</span><br><span class="line"><span class="built_in">string</span> s ;</span><br><span class="line"><span class="built_in">string</span> ss&#123;&#125; ;</span><br><span class="line">MyClass obj ;</span><br><span class="line">MyClass objj&#123;&#125; ;</span><br></pre></td></tr></table></figure></p><p>说到这里，就不得不提到 <strong><em>the Most Vexing Parse</em></strong> ，请看下面：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Timer();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper(<span class="keyword">const</span> Timer&amp; t);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_time</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TimeKeeper time_keeper(Timer());  // 1</span><br><span class="line">    <span class="keyword">return</span> time_keeper.get_time();    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>代码来自 <a href="https://en.wikipedia.org/wiki/Most_vexing_parse" title="most vexing parse" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>上面代码的标注1的那行会被看作是一个名字为<em>time_keep</em>的函数，返回值是 <em>TimeKeeper</em> 类型，参数是一个返回值为<em>Timer</em>类型的函数指针，而不是对象定义。要实现后者，可以这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeKeeper time_keeper((Timer());</span><br></pre></td></tr></table></figure><p>更好的做法是使用C++11定义的用{}来初始化对象,可以避免很多错误。</p><h2 id="用等于号：type-var-expression"><a href="#用等于号：type-var-expression" class="headerlink" title="用等于号：type var = expression"></a>用等于号：<strong>type var = expression</strong></h2><p>对于内置类型来说，=初始化和()初始化几乎没有区别(我也不知道区别在哪里)。</p><p>对于类类型，=初始化调用的是copy构造函数，而赋值是调用重载的=操作符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass c1 = c0 ;   <span class="comment">// call MyClass(const MyClass&amp;)</span></span><br><span class="line">c1 = c0 ;           <span class="comment">// call operator =(const MyClass&amp;)</span></span><br></pre></td></tr></table></figure><p>等于号经常和大括号{}一起用于初始化,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass c = &#123;<span class="number">1</span> , <span class="string">"123"</span>&#125; ;</span><br></pre></td></tr></table></figure><h2 id="用大括号：type-var-initializer-list-C-11推荐"><a href="#用大括号：type-var-initializer-list-C-11推荐" class="headerlink" title="用大括号：type var{initializer-list} //C++11推荐"></a>用大括号：<strong>type var{initializer-list}</strong> //C++11推荐</h2><p>C++11为了解决C++98混乱的初始化方式而提出的一种初始化方式: <strong><em>uniform initialization</em></strong> ，保证它可以用于所有的初始化。实现方式就是采用大括号。下面介绍一些{}与而其他初始化语法的不同之处：</p><pre><code>- 大括号初始化不允许对内置类型进行隐式的窄化类型转换(***implicit narrowing conversion***)，而但是注意，这个类型转换不仅仅依据类型，还会依据值的大小。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1&#123;<span class="number">10</span>&#125; ;   <span class="comment">// 正确，10是int 类型，但是可以char大小可以保存</span></span><br><span class="line"><span class="keyword">char</span> c2&#123;<span class="number">256</span>&#125; ;  <span class="comment">// 错误，256超过了char可保存的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i1</span><span class="params">(<span class="number">11.11</span>)</span> </span>; <span class="comment">// 正确，i1 == 11</span></span><br><span class="line"><span class="keyword">int</span> i2&#123;<span class="number">11.11</span>&#125; ; <span class="comment">// 错误，会出现精度损失</span></span><br></pre></td></tr></table></figure><ul><li>想要在定义非静态类成员时为成员赋初值(称为 <strong><em>default member initialize</em></strong>)，只能使用=和{}来初始化，不允许使用()。</li><li><p>初始化数组和标准库容器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br></pre></td></tr></table></figure></li><li><p>初始化不可复制的对象(<strong><em>uncopyable objects</em></strong>)，比如 <strong><em>std::atomic</em></strong> ,这里就只能用 {} 和 () ，而不能用 = 。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai_1&#123;<span class="number">0</span>&#125; ;    <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai_1(<span class="number">0</span>) ;    <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai_1 = <span class="number">0</span> ;   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h2 id="什么也不用：type-var"><a href="#什么也不用：type-var" class="headerlink" title="什么也不用：type var"></a>什么也不用：<strong>type var</strong></h2><p>有时候我们可能直接定义一个对象，没有添加=、{}、()以显式地初始化，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">string</span> s ;</span><br><span class="line">MyClass c ;</span><br></pre></td></tr></table></figure></p><p>这种情况下根据定义所在的位置和对象类型的不同，有不同的初始化行为。</p><ul><li><p>对于类类型，会自动调用类的默认构造函数来初始化对象。</p></li><li><p>对于内置类型，当变量在全局作用域或者被定义为局部静态变量时，会被<strong>默认初始化</strong>，一般是<strong>零初始化</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;   <span class="comment">// i == 0</span></span><br><span class="line"><span class="keyword">double</span> d ;<span class="comment">// d == 0</span></span><br><span class="line"><span class="keyword">bool</span> b ;  <span class="comment">// b == false</span></span><br><span class="line">MyClass c ;   <span class="comment">// 调用MyClass()构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i ;  <span class="comment">// i == 0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而对于自动变量，则默认初始化得到的是一个不定值。绝大多数情况下使用这个变量都会是一个未定义的行为，例外请参考：<a href="http://en.cppreference.com/w/cpp/language/default_initialization" title="默认初始化" target="_blank" rel="noopener">cppreference</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初始化的含义&quot;&gt;&lt;a href=&quot;#初始化的含义&quot; class=&quot;headerlink&quot; title=&quot;初始化的含义&quot;&gt;&lt;/a&gt;初始化的含义&lt;/h1&gt;&lt;p&gt;所谓初始化，就是给一个变量一个初始值，在使用一个变量的值之前，需要对其进行初始化，否则，得到的就&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="C++" scheme="https://oven-yang.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://oven-yang.github.io/tags/C/"/>
    
  </entry>
  
</feed>
